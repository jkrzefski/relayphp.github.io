{"name":"Relay","tagline":"A PSR-7 middleware dispatcher.","body":"# Middleware Signature\r\n\r\nA _Relay_ middleware callable must have the following signature:\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface as Response;\r\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\r\n\r\nfunction (\r\n    Request $request,   // the incoming request\r\n    Response $response, // the outgoing response\r\n    callable $next      // the next middleware\r\n) {\r\n    // ...\r\n}\r\n```\r\n\r\nA _Relay_ middleware callable must return an implementation of _Psr\\Http\\Message\\ResponseInterface_.\r\n\r\n# Middleware Dispatching\r\n\r\nCreate a `$queue` array of middleware callables:\r\n\r\n```php\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // 1st middleware\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // 2nd middleware\r\n};\r\n\r\n// ...\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // Nth middleware\r\n};\r\n```\r\n\r\nCreate a _Relay_ with the `$queue`, and invoke it with a request and response.\r\n\r\n```php\r\n/**\r\n * @var \\Psr\\Http\\Message\\ServerRequestInterface $request\r\n * @var \\Psr\\Http\\Message\\ResponseInterface $response\r\n */\r\n\r\nuse Relay\\Relay;\r\n\r\n$dispatcher = new Relay($queue);\r\n$dispatcher($request, $response);\r\n```\r\n\r\nThat will execute each of the middlewares in first-in-first-out order.\r\n\r\n# Middleware Logic\r\n\r\nYour middleware logic should follow this pattern:\r\n\r\n- Receive the incoming request and response objects from the previous middleware as parameters, along with the next middleware as a callable.\r\n\r\n- Optionally modify the received request and response as desired.\r\n\r\n- Optionally invoke the next middleware with the request and response, receiving a new response in return.\r\n\r\n- Optionally modify the returned response as desired.\r\n\r\n- Return the response to the previous middleware.\r\n\r\nHere is a skeleton example; your own middleware may or may not perform the various optional processes:\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface as Response;\r\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n\r\n    // optionally modify the incoming request\r\n    $request = $request->...;\r\n\r\n    // optionally skip the $next middleware and return early\r\n    if (...) {\r\n        return $response;\r\n    }\r\n\r\n    // optionally invoke the $next middleware and get back a new response\r\n    $response = $next($request, $response);\r\n\r\n    // optionally modify the Response if desired\r\n    $response = $response->...;\r\n\r\n    // NOT OPTIONAL: return the Response to the previous middleware\r\n    return $response;\r\n};\r\n```\r\n\r\n> N.b.: You should **always** return the response from your middleware logic.\r\n\r\nRemember that the request and response are **immutable**. Implicit in that is the fact that changes to the request are always transmitted to the `$next` middleware but never to the previous one.\r\n\r\nNote also that this logic chain means the request and response are subjected to two passes through each middleware:\r\n\r\n- first on the way \"in\" through each middleware via the `$next` middleware invocation,\r\n\r\n- then on the way \"out\" from each middleware via the `return` to the previous middleware.\r\n\r\nFor example, if the middleware queue looks like this:\r\n\r\n```php\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Foo\"\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Bar\"\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Baz\"\r\n};\r\n```\r\n\r\n... the request and response path through the middlewares will look like this:\r\n\r\n```\r\nFoo is 1st on the way in\r\n    Bar is 2nd on the way in\r\n        Baz is 3rd on the way in, and 1st on the way out\r\n    Bar is 2nd on the way out\r\nFoo is 3rd on the way out\r\n```\r\n\r\nYou can use this dual-pass logic in clever and perhaps unintuitive ways. For example, middleware placed at the very start may do nothing with the request and call `$next` right away, but it is the middleware with the \"real\" last opportunity to modify the response.\r\n\r\n# Resolvers\r\n\r\nYou may wish to use `$queue` entries other than anonymous functions. If so, you can pass a `$resolver` callable to the _Relay_ that will convert the `$queue` entry to a callable. Thus, using a `$resolver` allows you to pass in your own factory mechanism for `$queue` entries.\r\n\r\nFor example, this `$resolver` will naively convert `$queue` string entries to new class instances:\r\n\r\n```php\r\n$resolver = function ($class) {\r\n    return new $class();\r\n};\r\n```\r\n\r\nYou can then add `$queue` entries as class names, and the _Relay_ will use the\r\n`$resolver` to create the objects in turn.\r\n\r\n```php\r\nuse Relay\\Relay;\r\n\r\n$queue[] = 'FooMiddleware';\r\n$queue[] = 'BarMiddleware';\r\n$queue[] = 'BazMiddleware';\r\n\r\n$dispatcher = new Relay($queue, $resolver);\r\n```\r\n\r\nAs long as the classes listed in the `$queue` implement `__invoke(Request $request, Response $response, callable $next)`, then the _Relay_ will work correctly.\r\n\r\n# Queue Object and Relay Builder\r\n\r\nSometimes using an array for the `$queue` will not be suitable. You may wish to use an object to build retain the middleware queue. If so, you can use the _RelayBuilder_ to create the _Relay_ from any queue object that extends _ArrayObject_ or that implements _Relay\\GetArrayCopyInterface_. The _RelayBuilder_ will then get an array copy of the queue for the _Relay_.\r\n\r\nFor example, if your `$queue` is an _ArrayObject_, you can create the _RelayBuilder_ with an optional `$resolver` ...\r\n\r\n```php\r\nuse Relay\\RelayBuilder;\r\n\r\n$builder = new RelayBuilder($resolver);\r\n```\r\n\r\n... then you can create the _Relay_ with your `$queue` array, _ArrayObject_, or _GetArrayCopyInterface_:\r\n\r\n```php\r\n/**\r\n * var array|ArrayObject|GetArrayCopyInterface $queue\r\n */\r\n$relay = $builder->newInstance($queue);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}