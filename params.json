{"name":"Pipeline","tagline":"A PSR-7 middleware dispatcher.","body":"# Pipeline\r\n\r\nA PSR-7 middleware dispatcher.\r\n\r\n## Installation, Autoloading, and Tests\r\n\r\nThis package is installable and PSR-4 autoloadable via Composer as `pipeline/pipeline`.\r\n\r\nAlternatively, download a release or clone this repository, then map the `Pipeline\\Pipeline\\` namespace to the package `src/` directory.\r\n\r\nThis package requires PHP 5.5 or later; it has been tested on PHP 5.6, PHP 7, and HHVM. We recommend using the latest available version of PHP as a matter of principle.\r\n\r\nTo run the tests, issue `composer install` to install the test dependencies, then issue `phpunit`.\r\n\r\n## Middleware Signature\r\n\r\nA _Pipeline_ middleware callable must have the following signature:\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface as Response;\r\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\r\n\r\nfunction (\r\n    Request $request,   // the incoming request\r\n    Response $response, // the outgoing response\r\n    callable $next      // the next middleware\r\n) {\r\n    // ...\r\n}\r\n```\r\n\r\n## Middleware Dispatching\r\n\r\nCreate a `$queue` array of middleware callables:\r\n\r\n```php\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // 1st middleware\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // 2nd middleware\r\n};\r\n\r\n// ...\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // Nth middleware\r\n};\r\n```\r\n\r\nCreate a _Pipeline_ with the `$queue`, and invoke it with a request and response.\r\n\r\n```php\r\n/**\r\n * @var \\Psr\\Http\\Message\\ServerRequestInterface $request\r\n * @var \\Psr\\Http\\Message\\ResponseInterface $response\r\n */\r\n\r\nuse Pipeline\\Pipeline\\Pipeline;\r\n\r\n$dispatcher = new Pipeline($queue);\r\n$dispatcher($request, $response);\r\n```\r\n\r\nThat will execute each of the middlewares in first-in-first-out order.\r\n\r\n## Middleware Logic\r\n\r\nYour middleware logic should follow this pattern:\r\n\r\n- Receive the incoming request and response objects from the previous middleware as parameters, along with the next middleware as a callable.\r\n\r\n- Optionally modify the received request and response as desired.\r\n\r\n- Optionally invoke the next middleware with the request and response, receiving a new response in return.\r\n\r\n- Optionally modify the returned response as desired.\r\n\r\n- Return the response to the previous middleware.\r\n\r\nHere is a skeleton example; your own middleware may or may not perform the various optional processes:\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface as Response;\r\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n\r\n    // optionally modify the incoming request\r\n    $request = $request->...;\r\n\r\n    // optionally skip the $next middleware and return early\r\n    if (...) {\r\n        return $response;\r\n    }\r\n\r\n    // optionally invoke the $next middleware and get back a new response\r\n    $response = $next($request, $response);\r\n\r\n    // optionally modify the Response if desired\r\n    $response = $response->...;\r\n\r\n    // NOT OPTIONAL: return the Response to the previous middleware\r\n    return $response;\r\n};\r\n```\r\n\r\n> N.b.: You should **always** return the response from your middleware logic.\r\n\r\nRemember that the request and response are **immutable**. Implicit in that is the fact that changes to the request are always transmitted to the `$next` middleware but never to the previous one.\r\n\r\nNote also that this logic chain means the request and response are subjected to two passes through each middleware:\r\n\r\n- first on the way \"in\" through each middleware via the `$next` middleware invocation,\r\n\r\n- then on the way \"out\" from each middleware via the `return` to the previous middleware.\r\n\r\nFor example, if the middleware queue looks like this:\r\n\r\n```php\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Foo\"\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Bar\"\r\n};\r\n\r\n$queue[] = function (Request $request, Response $response, callable $next) {\r\n    // \"Baz\"\r\n};\r\n```\r\n\r\n... the request and response path through the middlewares will look like this:\r\n\r\n```\r\nFoo is 1st on the way in\r\n    Bar is 2nd on the way in\r\n        Baz is 3rd on the way in, and 1st on the way out\r\n    Bar is 2nd on the way out\r\nFoo is 3rd on the way out\r\n```\r\n\r\nYou can use this dual-pass logic in clever and perhaps unintuitive ways. For example, middleware placed at the very start may do nothing with the request and call `$next` right away, but it is the middleware with the \"real\" last opportunity to modify the response.\r\n\r\n## Resolvers\r\n\r\nYou may wish to use `$queue` entries other than anonymous functions. If so, you can pass a `$resolver` callable to the _Pipeline_ that will convert the `$queue` entry to a callable. Thus, using a `$resolver` allows you to pass in your own factory mechanism for `$queue` entries.\r\n\r\nFor example, this `$resolver` will naively convert `$queue` string entries to new class instances:\r\n\r\n```php\r\n$resolver = function ($class) {\r\n    return new $class();\r\n};\r\n```\r\n\r\nYou can then add `$queue` entries as class names, and the _Pipeline_ will use the\r\n`$resolver` to create the objects in turn.\r\n\r\n```php\r\nuse Pipeline\\Pipeline\\Pipeline;\r\n\r\n$queue[] = 'FooMiddleware';\r\n$queue[] = 'BarMiddleware';\r\n$queue[] = 'BazMiddleware';\r\n\r\n$dispatcher = new Pipeline($queue, $resolver);\r\n```\r\n\r\nAs long as the classes listed in the `$queue` implement `__invoke(Request $request, Response $response, callable $next)`, then the _Pipeline_ will work correctly.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}