<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pipeline by pipelinephp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pipeline</h1>
      <h2 class="project-tagline">A PSR-7 middleware dispatcher.</h2>
    </section>

    <section class="main-content">
      <h1>
<a id="middleware-signature" class="anchor" href="#middleware-signature" aria-hidden="true"><span class="octicon octicon-link"></span></a>Middleware Signature</h1>

<p>A <em>Pipeline</em> middleware callable must have the following signature:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Psr\Http\Message\ResponseInterface</span> <span class="pl-k">as</span> <span class="pl-c1">Response</span>;</span>
<span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Psr\Http\Message\ServerRequestInterface</span> <span class="pl-k">as</span> <span class="pl-c1">Request</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-k">function</span> (</span>
<span class="pl-s1">    <span class="pl-c1">Request</span> <span class="pl-smi">$request</span>,   <span class="pl-c">// the incoming request</span></span>
<span class="pl-s1">    <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c">// the outgoing response</span></span>
<span class="pl-s1">    <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>      <span class="pl-c">// the next middleware</span></span>
<span class="pl-s1">) {</span>
<span class="pl-s1">    <span class="pl-c">// ...</span></span>
<span class="pl-s1">}</span></pre></div>

<p>A <em>Pipeline</em> middleware callable must return an implementation of <em>Psr\Http\Message\ResponseInterface</em>.</p>

<h1>
<a id="middleware-dispatching" class="anchor" href="#middleware-dispatching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Middleware Dispatching</h1>

<p>Create a <code>$queue</code> array of middleware callables:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// 1st middleware</span></span>
<span class="pl-s1">};</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// 2nd middleware</span></span>
<span class="pl-s1">};</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-c">// ...</span></span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// Nth middleware</span></span>
<span class="pl-s1">};</span></pre></div>

<p>Create a <em>Pipeline</em> with the <code>$queue</code>, and invoke it with a request and response.</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-c">/**</span></span>
<span class="pl-s1"><span class="pl-c"> * <span class="pl-k">@var</span> \Psr\Http\Message\ServerRequestInterface $request</span></span>
<span class="pl-s1"><span class="pl-c"> * <span class="pl-k">@var</span> \Psr\Http\Message\ResponseInterface $response</span></span>
<span class="pl-s1"><span class="pl-c"> */</span></span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Pipeline\Pipeline\Pipeline</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$dispatcher</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-c1">Pipeline</span>(<span class="pl-smi">$queue</span>);</span>
<span class="pl-s1">$<span class="pl-smi">dispatcher</span>(<span class="pl-smi">$request</span>, <span class="pl-smi">$response</span>);</span></pre></div>

<p>That will execute each of the middlewares in first-in-first-out order.</p>

<h1>
<a id="middleware-logic" class="anchor" href="#middleware-logic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Middleware Logic</h1>

<p>Your middleware logic should follow this pattern:</p>

<ul>
<li><p>Receive the incoming request and response objects from the previous middleware as parameters, along with the next middleware as a callable.</p></li>
<li><p>Optionally modify the received request and response as desired.</p></li>
<li><p>Optionally invoke the next middleware with the request and response, receiving a new response in return.</p></li>
<li><p>Optionally modify the returned response as desired.</p></li>
<li><p>Return the response to the previous middleware.</p></li>
</ul>

<p>Here is a skeleton example; your own middleware may or may not perform the various optional processes:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Psr\Http\Message\ResponseInterface</span> <span class="pl-k">as</span> <span class="pl-c1">Response</span>;</span>
<span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Psr\Http\Message\ServerRequestInterface</span> <span class="pl-k">as</span> <span class="pl-c1">Request</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c">// optionally modify the incoming request</span></span>
<span class="pl-s1">    <span class="pl-smi">$request</span> <span class="pl-k">=</span> <span class="pl-smi">$request</span><span class="pl-k">-&gt;</span><span class="pl-k">...</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c">// optionally skip the $next middleware and return early</span></span>
<span class="pl-s1">    <span class="pl-k">if</span> (<span class="pl-k">...</span>) {</span>
<span class="pl-s1">        <span class="pl-k">return</span> <span class="pl-smi">$response</span>;</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c">// optionally invoke the $next middleware and get back a new response</span></span>
<span class="pl-s1">    <span class="pl-smi">$response</span> <span class="pl-k">=</span> $<span class="pl-smi">next</span>(<span class="pl-smi">$request</span>, <span class="pl-smi">$response</span>);</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c">// optionally modify the Response if desired</span></span>
<span class="pl-s1">    <span class="pl-smi">$response</span> <span class="pl-k">=</span> <span class="pl-smi">$response</span><span class="pl-k">-&gt;</span><span class="pl-k">...</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c">// NOT OPTIONAL: return the Response to the previous middleware</span></span>
<span class="pl-s1">    <span class="pl-k">return</span> <span class="pl-smi">$response</span>;</span>
<span class="pl-s1">};</span></pre></div>

<blockquote>
<p>N.b.: You should <strong>always</strong> return the response from your middleware logic.</p>
</blockquote>

<p>Remember that the request and response are <strong>immutable</strong>. Implicit in that is the fact that changes to the request are always transmitted to the <code>$next</code> middleware but never to the previous one.</p>

<p>Note also that this logic chain means the request and response are subjected to two passes through each middleware:</p>

<ul>
<li><p>first on the way "in" through each middleware via the <code>$next</code> middleware invocation,</p></li>
<li><p>then on the way "out" from each middleware via the <code>return</code> to the previous middleware.</p></li>
</ul>

<p>For example, if the middleware queue looks like this:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// "Foo"</span></span>
<span class="pl-s1">};</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// "Bar"</span></span>
<span class="pl-s1">};</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-c1">Request</span> <span class="pl-smi">$request</span>, <span class="pl-c1">Response</span> <span class="pl-smi">$response</span>, <span class="pl-c1">callable</span> <span class="pl-smi">$next</span>) {</span>
<span class="pl-s1">    <span class="pl-c">// "Baz"</span></span>
<span class="pl-s1">};</span></pre></div>

<p>... the request and response path through the middlewares will look like this:</p>

<pre><code>Foo is 1st on the way in
    Bar is 2nd on the way in
        Baz is 3rd on the way in, and 1st on the way out
    Bar is 2nd on the way out
Foo is 3rd on the way out
</code></pre>

<p>You can use this dual-pass logic in clever and perhaps unintuitive ways. For example, middleware placed at the very start may do nothing with the request and call <code>$next</code> right away, but it is the middleware with the "real" last opportunity to modify the response.</p>

<h1>
<a id="resolvers" class="anchor" href="#resolvers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resolvers</h1>

<p>You may wish to use <code>$queue</code> entries other than anonymous functions. If so, you can pass a <code>$resolver</code> callable to the <em>Pipeline</em> that will convert the <code>$queue</code> entry to a callable. Thus, using a <code>$resolver</code> allows you to pass in your own factory mechanism for <code>$queue</code> entries.</p>

<p>For example, this <code>$resolver</code> will naively convert <code>$queue</code> string entries to new class instances:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-smi">$resolver</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">$class</span>) {</span>
<span class="pl-s1">    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">$class</span>();</span>
<span class="pl-s1">};</span></pre></div>

<p>You can then add <code>$queue</code> entries as class names, and the <em>Pipeline</em> will use the
<code>$resolver</code> to create the objects in turn.</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Pipeline\Pipeline\Pipeline</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>FooMiddleware<span class="pl-pds">'</span></span>;</span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>BarMiddleware<span class="pl-pds">'</span></span>;</span>
<span class="pl-s1"><span class="pl-smi">$queue</span>[] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>BazMiddleware<span class="pl-pds">'</span></span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$dispatcher</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-c1">Pipeline</span>(<span class="pl-smi">$queue</span>, <span class="pl-smi">$resolver</span>);</span></pre></div>

<p>As long as the classes listed in the <code>$queue</code> implement <code>__invoke(Request $request, Response $response, callable $next)</code>, then the <em>Pipeline</em> will work correctly.</p>

<h1>
<a id="queue-object-and-pipeline-builder" class="anchor" href="#queue-object-and-pipeline-builder" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queue Object and Pipeline Builder</h1>

<p>Sometimes using an array for the <code>$queue</code> will not be suitable. You may wish to use an object to build retain the middleware queue. If so, you can use the <em>PipelineBuilder</em> to create the <em>Pipeline</em> from any queue object that extends <em>ArrayObject</em> or that implements <em>Pipeline\Pipeline\GetArrayCopyInterface</em>. The <em>PipelineBuilder</em> will then get an array copy of the queue for the <em>Pipeline</em>.</p>

<p>For example, if your <code>$queue</code> is an <em>ArrayObject</em>, you can create the <em>PipelineBuilder</em> with an optional <code>$resolver</code> ...</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-k">use</span> <span class="pl-c1">Pipeline\Pipeline\PipelineBuilder</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$builder</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-c1">PipelineBuilder</span>(<span class="pl-smi">$resolver</span>);</span></pre></div>

<p>... then you can create the <em>Pipeline</em> with your <code>$queue</code> array, <em>ArrayObject</em>, or <em>GetArrayCopyInterface</em>:</p>

<div class="highlight highlight-php"><pre><span class="pl-s1"><span class="pl-c">/**</span></span>
<span class="pl-s1"><span class="pl-c"> * var array|ArrayObject|GetArrayCopyInterface $queue</span></span>
<span class="pl-s1"><span class="pl-c"> */</span></span>
<span class="pl-s1"><span class="pl-smi">$pipeline</span> <span class="pl-k">=</span> <span class="pl-smi">$builder</span><span class="pl-k">-&gt;</span>newInstance(<span class="pl-smi">$queue</span>);</span></pre></div>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

